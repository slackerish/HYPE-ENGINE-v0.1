<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Friday Night Funkin': Hype Engine v0.1 | By Rhap5ody</title>

    <link id="favicon" rel="icon"
        href="https://raw.githubusercontent.com/slackerish/HYPE-ENGINE-v0.1/main/system/favicons/icon.png" />

    <style>
        /* =====================================================
           BASE
        ===================================================== */
        html,
        body {
            margin: 0;
            padding: 0;
            width: 100%;
            height: 100%;
            overflow: hidden;
            background: black;
        }

        /* =====================================================
           BACKGROUNDS
        ===================================================== */
        .bgToPlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            z-index: 0;
            background-size: cover;
            background-position: center;
            background-repeat: no-repeat;
            opacity: 0;
            transition: opacity 1s ease, transform 0.3s ease;
        }

        .bgToPlay.visible {
            opacity: 1;
        }

        .bgToPlay.zoomed {
            transform: scale(1.03);
        }

        .bgToPlay.hidden {
            opacity: 0;
            display: none;
        }

        .mainBg {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            z-index: 0;
            background-size: cover;
            background-position: center;
            background-repeat: no-repeat;
            background-image: url("https://raw.githubusercontent.com/slackerish/HYPE-ENGINE-v0.1/main/assets/images/menuBG.png");
            display: none;
        }

        .mainBg.visible {
            display: block;
        }

        /* =====================================================
           FLASH
        ===================================================== */
        .white-flash {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            background: white;
            z-index: 10;
            opacity: 0;
            pointer-events: none;
        }

        .white-flash.flash {
            animation: flashAnimation 0.5s ease;
        }

        @keyframes flashAnimation {
            0% {
                opacity: 0;
            }

            50% {
                opacity: 1;
            }

            100% {
                opacity: 0;
            }
        }

        /* =====================================================
           HITBOX
        ===================================================== */
        .hitbox {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 40vw;
            height: 40vh;
            z-index: 2;
            cursor: pointer;
            opacity: 0;
            pointer-events: none;
        }

        .hitbox.visible {
            opacity: 1;
            pointer-events: auto;
        }

        .hitbox.hidden {
            opacity: 0;
            pointer-events: none;
            display: none;
        }

        /* =====================================================
           CANVAS
        ===================================================== */
        canvas {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 1;
            opacity: 1;
            transition: opacity 1s ease;
        }

        canvas.fade-out {
            opacity: 0;
        }

        /* =====================================================
           LOADING
        ===================================================== */
        .loading-percentage {
            position: absolute;
            top: 20px;
            left: 20px;
            color: white;
            font-size: 22px;
            z-index: 3;
            transition: opacity 0.6s ease;
        }

        .loading-data {
            position: absolute;
            top: 10px;
            right: 10px;
            font-family: Palatino, URW Palladio L, serif;
            color: white;
            font-size: 12px;
            z-index: 3;
            transition: opacity 0.8s ease-in-out;
            text-align: right;
        }

        .fade-out-ui {
            opacity: 0;
        }

        /* =====================================================
           TOP LEFT INFO
        ===================================================== */
        .top-left-info {
            position: fixed;
            top: 10px;
            left: 10px;
            color: white;
            font-size: 14px;
            z-index: 6;
            opacity: 0;
            transition: opacity 0.5s ease;
        }

        /* =====================================================
           MENU
        ===================================================== */
        .menu-container {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            z-index: 5;
            display: none;
            width: 500px;
            height: 800px;
        }

        .menu-container.visible {
            display: block;
        }

        .menu-item {
            position: absolute;
            left: 50%;
            transform: translateX(-50%);
            width: 400px;
            height: 150px;
            opacity: 0;
            transition: opacity 0.3s ease, top 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275);
            pointer-events: none;
        }

        .menu-item.visible-item {
            opacity: 0.6;
            pointer-events: auto;
        }

        .menu-item.selected {
            opacity: 1;
        }

        .menu-item canvas {
            width: 100%;
            height: 100%;
        }

        @keyframes confirmFlicker {
            0% {
                opacity: 1;
            }

            50% {
                opacity: 0;
            }

            100% {
                opacity: 1;
            }
        }

        .menu-item.confirming {
            animation: confirmFlicker 0.1s infinite;
        }
    </style>
</head>

<body>

    <div id="containBgToPlay" class="bgToPlay"></div>
    <div id="mainBg" class="mainBg"></div>
    <div id="whiteFlash" class="white-flash"></div>
    <div id="hitbox" class="hitbox"></div>

    <div id="load" class="loading-percentage">
        <span id="percentageLoading">0%</span>
    </div>

    <div id="loadingData" class="loading-data">
        HYPE ENGINE VERSION: 0.1
    </div>

    <div id="topLeftInfo" class="top-left-info">
        Friday Night Funkin' v0.6.3<br />
        HYPE ENGINE v0.1
    </div>

    <canvas id="animCanvas"></canvas>
    <div id="menuContainer" class="menu-container"></div>

    <script>
        /* =====================================================
           DOM REFERENCES
        ===================================================== */
        const loaderText = document.getElementById("percentageLoading");
        const load = document.getElementById("load");
        const loadingData = document.getElementById("loadingData");
        const topLeftInfo = document.getElementById("topLeftInfo");
        const canvas = document.getElementById("animCanvas");
        const bgContainer = document.getElementById("containBgToPlay");
        const mainBg = document.getElementById("mainBg");
        const whiteFlash = document.getElementById("whiteFlash");
        const hitbox = document.getElementById("hitbox");
        const menuContainer = document.getElementById("menuContainer");

        /* =====================================================
           STATE
        ===================================================== */
        let canStart = false;
        let hasStarted = false;
        let isSelecting = false;

        const menuItems = [
            "menu_story_mode",
            "menu_freeplay",
            "menu_credits",
            "menu_mods",
            "menu_awards",
            "menu_donate"
        ];

        let currentMenuIndex = 0;
        let menuSprites = [];

        /* =====================================================
           BACKGROUND IMAGE RANDOMIZER
        ===================================================== */
        const images = [
            "https://raw.githubusercontent.com/slackerish/HYPE-ENGINE-v0.1/main/hype/images/bfToPlay.png",
            "https://raw.githubusercontent.com/slackerish/HYPE-ENGINE-v0.1/main/hype/images/gfToPlay.png"
        ];

        const selectedImage = images[Math.floor(Math.random() * images.length)];

        const preload = new Image();
        preload.src = selectedImage;
        preload.onload = () => {
            bgContainer.style.backgroundImage = `url("${selectedImage}")`;
        };

        /* =====================================================
           AUDIO
        ===================================================== */
        const startSound = new Audio("https://raw.githubusercontent.com/slackerish/HYPE-ENGINE-v0.1/main/assets/sounds/confirmMenu.mp3");
        const scrollSound = new Audio("https://raw.githubusercontent.com/slackerish/HYPE-ENGINE-v0.1/main/assets/sounds/scrollMenu.mp3");
        const bgMusic = new Audio("https://raw.githubusercontent.com/slackerish/HYPE-ENGINE-v0.1/main/assets/music/freakyMenu.mp3");
        bgMusic.loop = true;

        /* =====================================================
           MENU BG FLICKER
        ===================================================== */
        const menuBGBasePath = "https://raw.githubusercontent.com/slackerish/HYPE-ENGINE-v0.1/main/assets/images/";
        let flickerInterval = null;
        let flickerToggle = false;

        function startMenuBGFlicker() {
            if (flickerInterval) clearInterval(flickerInterval);

            const blueBG = menuBGBasePath + "menuBGBlue.png";
            const magentaBG = menuBGBasePath + "menuBGMagenta.png";

            flickerInterval = setInterval(() => {
                flickerToggle = !flickerToggle;
                mainBg.style.backgroundImage =
                    `url("${flickerToggle ? blueBG : magentaBG}")`;
            }, 100);
        }

        function stopMenuBGFlicker() {
            if (flickerInterval) {
                clearInterval(flickerInterval);
                flickerInterval = null;
            }

            mainBg.style.backgroundImage =
                `url("${menuBGBasePath}menuBG.png")`;
        }

        /* =====================================================
           START GAME
        ===================================================== */
        function startGame() {
            if (!canStart || hasStarted) return;

            hasStarted = true;

            startSound.play();
            bgMusic.play();

            whiteFlash.classList.add("flash");
            bgContainer.classList.add("hidden");
            hitbox.classList.add("hidden");
            mainBg.classList.add("visible");
            menuContainer.classList.add("visible");

            updateMenuLayout();

            setTimeout(() => {
                whiteFlash.classList.remove("flash");
            }, 500);
        }

        /* =====================================================
           INPUT
        ===================================================== */
        document.addEventListener("click", (e) => {
            if (e.target === hitbox || hitbox.contains(e.target)) {
                startGame();
            }
        });

        document.addEventListener("keydown", (e) => {
            if (!hasStarted && (e.code === "Space" || e.code === "Enter")) {
                startGame();
            }

            if (hasStarted && !isSelecting) {
                if (e.code === "ArrowUp") {
                    e.preventDefault();
                    changeSelection(-1);
                } else if (e.code === "ArrowDown") {
                    e.preventDefault();
                    changeSelection(1);
                } else if (e.code === "Space" || e.code === "Enter") {
                    e.preventDefault();
                    selectCurrentMenuItem();
                }
            }
        });

        /* =====================================================
           MENU LOGIC
        ===================================================== */

        function changeSelection(change) {
            scrollSound.currentTime = 0;
            scrollSound.play();

            currentMenuIndex += change;

            if (currentMenuIndex < 0)
                currentMenuIndex = menuSprites.length - 1;

            if (currentMenuIndex >= menuSprites.length)
                currentMenuIndex = 0;

            updateMenuSelection();
            updateMenuLayout();
        }

        function updateMenuLayout() {
            const itemHeight = 110;
            const gap = 18;
            const centerY = menuContainer.offsetHeight / 2 - 75;

            menuSprites.forEach((sprite, index) => {
                let diff = index - currentMenuIndex;

                if (diff > menuSprites.length / 2)
                    diff -= menuSprites.length;

                if (diff < -menuSprites.length / 2)
                    diff += menuSprites.length;

                const targetY = centerY + (diff * (itemHeight + gap));
                sprite.container.style.top = `${targetY}px`;

                if (Math.abs(diff) <= 2) {
                    sprite.container.classList.add("visible-item");
                } else {
                    sprite.container.classList.remove("visible-item");
                }
            });
        }

        hitbox.addEventListener("mouseenter", () => {
            if (!hasStarted)
                bgContainer.classList.add("zoomed");
        });

        hitbox.addEventListener("mouseleave", () => {
            if (!hasStarted)
                bgContainer.classList.remove("zoomed");
        });

        /* =====================================================
           MENU SPRITE CLASS
        ===================================================== */

        class MenuSprite {

            constructor(name, index) {
                this.name = name.replace("menu_", "");
                this.index = index;
                this.selected = false;

                this.frames = {
                    basic: [],
                    white: []
                };

                this.currentFrame = 0;
                this.fps = 24;
                this.lastTime = 0;

                this.container = document.createElement("div");
                this.container.className = "menu-item";

                this.canvas = document.createElement("canvas");
                this.canvas.width = 400;
                this.canvas.height = 150;

                this.ctx = this.canvas.getContext("2d");

                this.container.appendChild(this.canvas);

                this.container.addEventListener("click", () => {
                    if (hasStarted && !isSelecting) {
                        if (currentMenuIndex === this.index) {
                            selectCurrentMenuItem();
                        } else {
                            currentMenuIndex = this.index;
                            updateMenuSelection();
                            updateMenuLayout();
                        }
                    }
                });

                this.container.style.cursor = "pointer";
                menuContainer.appendChild(this.container);

                this.loadResources();
            }

            async loadResources() {
                const basePath =
                    "https://raw.githubusercontent.com/slackerish/HYPE-ENGINE-v0.1/main/assets/images/mainmenu/";

                const menuName = this.name;

                this.image = new Image();
                this.image.src = `${basePath}menu_${menuName}.png`;

                await this.loadXML(
                    `${basePath}menu_${menuName}.xml`,
                    menuName
                );

                this.animate();
            }

            async loadXML(url, menuName) {
                try {
                    const response = await fetch(url);
                    const xmlText = await response.text();

                    const parser = new DOMParser();
                    const xml = parser.parseFromString(xmlText, "application/xml");

                    const subTextures =
                        xml.getElementsByTagName("SubTexture");

                    for (let i = 0; i < subTextures.length; i++) {
                        const name =
                            subTextures[i].getAttribute("name");

                        const frameData = {
                            x: parseInt(subTextures[i].getAttribute("x")),
                            y: parseInt(subTextures[i].getAttribute("y")),
                            width: parseInt(subTextures[i].getAttribute("width")),
                            height: parseInt(subTextures[i].getAttribute("height"))
                        };

                        if (name.includes(`${menuName} basic`)) {
                            this.frames.basic.push(frameData);
                        }
                        else if (name.includes(`${menuName} white`)) {
                            this.frames.white.push(frameData);
                        }
                    }
                }
                catch (e) {
                    console.error(e);
                }
            }

            animate(timestamp = 0) {
                if (!this.lastTime)
                    this.lastTime = timestamp;

                const delta = timestamp - this.lastTime;

                if (delta > 1000 / this.fps) {
                    this.lastTime = timestamp;

                    this.draw();

                    const cur =
                        this.selected
                            ? this.frames.white
                            : this.frames.basic;

                    if (cur.length > 0)
                        this.currentFrame =
                            (this.currentFrame + 1) % cur.length;
                }

                requestAnimationFrame((t) =>
                    this.animate(t)
                );
            }

            draw() {
                const cur =
                    this.selected
                        ? this.frames.white
                        : this.frames.basic;

                if (cur.length === 0 || !this.image.complete)
                    return;

                const frame = cur[this.currentFrame];

                this.ctx.clearRect(
                    0,
                    0,
                    this.canvas.width,
                    this.canvas.height
                );

                const scale = Math.min(
                    this.canvas.width / frame.width,
                    this.canvas.height / frame.height
                );

                const dw = frame.width * scale;
                const dh = frame.height * scale;

                this.ctx.drawImage(
                    this.image,
                    frame.x,
                    frame.y,
                    frame.width,
                    frame.height,
                    (this.canvas.width - dw) / 2,
                    (this.canvas.height - dh) / 2,
                    dw,
                    dh
                );
            }

            setSelected(selected) {
                this.selected = selected;
                this.currentFrame = 0;

                if (selected)
                    this.container.classList.add("selected");
                else
                    this.container.classList.remove("selected");
            }
        }

        /* =====================================================
           MENU INITIALIZATION
        ===================================================== */

        function initializeMenu() {
            menuItems.forEach((item, index) => {
                const sprite =
                    new MenuSprite(item, index);

                menuSprites.push(sprite);
            });

            updateMenuSelection();
        }

        function updateMenuSelection() {
            menuSprites.forEach((sprite, index) => {
                sprite.setSelected(
                    index === currentMenuIndex
                );
            });
        }

        function selectCurrentMenuItem() {
            if (isSelecting)
                return;

            isSelecting = true;

            startSound.currentTime = 0;
            startSound.play();

            const selectedItem =
                menuSprites[currentMenuIndex];

            selectedItem.container
                .classList.add("confirming");

            startMenuBGFlicker();

            menuSprites.forEach((sprite, index) => {
                if (index !== currentMenuIndex) {
                    sprite.container.style.opacity = "0";
                }
            });

            console.log("Entering:", selectedItem.name);

            setTimeout(() => {

                stopMenuBGFlicker();

                selectedItem.container
                    .classList.remove("confirming");

                menuSprites.forEach((sprite, index) => {
                    sprite.container.style.opacity = "";
                    sprite.setSelected(
                        index === currentMenuIndex
                    );
                });

                isSelecting = false;

            }, 2000);
        }

        setTimeout(initializeMenu, 100);

        /* =====================================================
           FAKE LOADING
        ===================================================== */

        let progress = 0;

        const timer = setInterval(() => {
            progress += 1;

            if (progress >= 100) {
                progress = 100;

                loaderText.textContent = "100%";
                clearInterval(timer);

                load.classList.add("fade-out-ui");
                loadingData.classList.add("fade-out-ui");
                canvas.classList.add("fade-out");

                setTimeout(() => {
                    bgContainer.classList.add("visible");
                    hitbox.classList.add("visible");
                    canStart = true;
                }, 1000);

                setTimeout(() => {
                    canvas.remove();
                    load.remove();
                    loadingData.remove();
                }, 1800);
            }
            else {
                loaderText.textContent =
                    Math.floor(progress) + "%";
            }

        }, 30);

        /* =====================================================
           INTRO CANVAS ANIMATION
        ===================================================== */

        const ctx = canvas.getContext("2d");

        function resizeCanvas() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
        }

        resizeCanvas();
        window.addEventListener("resize", resizeCanvas);

        const introImg = new Image();
        introImg.src =
            "https://raw.githubusercontent.com/slackerish/HYPE-ENGINE-v0.1/main/hype/images/HYPEINITUALIZE.png";

        let introFrames = [];
        let introIdx = 0;

        fetch(
            "https://raw.githubusercontent.com/slackerish/HYPE-ENGINE-v0.1/main/hype/images/HYPEINITUALIZE.xml"
        )
            .then(r => r.text())
            .then(txt => {

                const xml =
                    new DOMParser()
                        .parseFromString(txt, "application/xml");

                const texs =
                    xml.getElementsByTagName("SubTexture");

                for (let t of texs) {
                    introFrames.push({
                        x: parseInt(t.getAttribute("x")),
                        y: parseInt(t.getAttribute("y")),
                        width: parseInt(t.getAttribute("width")),
                        height: parseInt(t.getAttribute("height"))
                    });
                }

                const loopIntro = () => {

                    if (introFrames.length > 0) {

                        const f = introFrames[introIdx];

                        ctx.clearRect(
                            0,
                            0,
                            canvas.width,
                            canvas.height
                        );

                        const s = Math.max(
                            canvas.width / f.width,
                            canvas.height / f.height
                        );

                        const dw = f.width * s;
                        const dh = f.height * s;

                        ctx.drawImage(
                            introImg,
                            f.x,
                            f.y,
                            f.width,
                            f.height,
                            (canvas.width - dw) / 2,
                            (canvas.height - dh) / 2,
                            dw,
                            dh
                        );

                        introIdx =
                            (introIdx + 1) %
                            introFrames.length;
                    }

                    requestAnimationFrame(loopIntro);
                };

                introImg.onload = () =>
                    requestAnimationFrame(loopIntro);
            });

        /* =====================================================
           STARTGAME HOOK
        ===================================================== */

        const originalStartGame = startGame;

        startGame = function () {
            originalStartGame.apply(this, arguments);

            if (topLeftInfo) {
                topLeftInfo.style.opacity = "1";
            }
        };

    </script>
</body>

</html>
